group2$Subject <- factor(group2$Subject)
group2$Answer <- factor(group2$Answer)
group2$Congruency <- factor(group2$Congruency)
group2$ResponseType <- factor(group2$ResponseType)
group2$Target.RESP <- factor(group2$Target.RESP)
group2$Target.RT <- as.numeric(group2$Target.RT)
group2$Group <- factor(group2$Group)
group3 <- subset(group2, Congruency != "" & Congruency != "NULL")
group3$Congruency <- factor(group3$Congruency)
group3$ResponseType <- factor(group3$ResponseType)
group3$Session.order <- factor(group3$Session.order)
str(group3)
sum(is.na(group3$Target.RT))
group4 <- group3[complete.cases(group3$Target.RT),]
group5 <- subset(group4, Target.RT >= 300)
group.rel <- subset(group5, Accuracy == 1)
group.rel <- ddply(group5, .(Subject),mutate, rel_max = mean(Target.RT) + 2.5*sd(Target.RT), rel_min = mean(Target.RT) - 2.5*sd(Target.RT))
group.rel$min_out <- ifelse(group.rel$Target.RT <= group.rel$rel_min,1,0)
group.rel$max_out <- ifelse(group.rel$Target.RT >= group.rel$rel_max,1,0)
group.rel$RT_final <- ifelse(group.rel$Target.RT >= group.rel$rel_max, group.rel$rel_max, ifelse(group.rel$Target.RT <= group.rel$rel_min, group.rel$rel_min, group.rel$Target.RT))
write.csv(group.rel, "Group_DataTrimmed_041117.csv", row.names = FALSE)
subj.means <- ddply(group.rel, .(Subject, Group, Session.order, Congruency, ResponseType), summarize, RT.MEAN = mean(Target.RT), RT.SE = sd(Target.RT)/length(Target.RT))
write.csv(subj.means, "Subj_Means_041117.csv", row.names = FALSE)
str(subj.means)
ggplot(subj.means, aes(ResponseType, RT.MEAN, fill = Congruency)) + stat_summary(fun.y = mean, geom = "bar", position = "dodge") + stat_summary(fun.data = mean_se, geom = "errorbar", position = "dodge") + facet_grid(Group~Session.order)
ggsave("Groups_RT_041117.png", height = 5, width = 7)
group.ez <- ezANOVA(data = subj.means,
dv = RT.MEAN,
wid = Subject,
within = .(Congruency, ResponseType, Session.order),
between = Group
)
bi.ez <- ezANOVA(data = subj.means[subj.means$Group == "Bilingual",],
dv = RT.MEAN,
wid = Subject,
within = .(Congruency, ResponseType, Session.order)#,
#between = Group
)
group.ez
head(subj.means)
group.ez <- ezANOVA(data = subj.means,
dv = RT.MEAN,
wid = Subject,
within = .(Congruency, ResponseType, Session.order),
between = Group
)
subj.means
head(subj.means)
str(subj.means)
subj.means <- subset(subj.means, Subject != "48" & Group == "Bilingual" | Subject ! = "49" & Group == "Bilingual")
subj.means <- subset(subj.means, Subject != "48" | Subject ! = "49")
?subset
subj.means <- subset(subj.means, Subject != "48")
subj.means <- subset(subj.means, Subject != "49")
subj.means$Subject <- factor(subject.means$Subject)
subj.means$Subject <- factor(subj.means$Subject)
group.ez <- ezANOVA(data = subj.means,
dv = RT.MEAN,
wid = Subject,
within = .(Congruency, ResponseType, Session.order),
between = Group
)
sum(24936,25684,26454)
sum(9815,7690,7431)
load(mtcars)
head(mtcars)
sum(.66,1.5,.25,1,.75)
100-4.16
59.58/59.35
59.58/59.35/100
59.58/59.35/100-1
59.35/59.58
1-59.35/59.58
(1-59.35/59.58)*100
(1-242.55/27.50)*100
(1-242.55/247.50)*100
(1-181.54/184.66)*100
(1-61.46/62.24)*100
(1-60.48/61.15)*100
10662.68-5268.25
10662.68-5394.43
5268.25-1807.59
citation()
?grep
version()
Version()
install.packages(c("tidyverse","car","ez","effects","lmer"))
install.packages("lme4")
sum(395, 100, 460, 144)
sum(395,100,460)
12000-10767
a <- 3
b <- 4
c <- a*b
c
library(tidyverse)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
print(tibble)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
print(df)
mean(df$a)
mean(df$b)
mean(df$c)
mean(df$d)
results <- vector("double", ncol(df)) #create a vector that is of class "double", that is the length of the number of columns in **df**
for (i in seq_along(df)) {
results[[i]] <- mean(df[[i]])
}
results
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
str(output)
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
head(output)
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
print(output)
#A simple while loop that shows us how many tries it takes to get three heads in a row
flip <- function() sample(c("T", "H"), 1) #sample from "T"|"H" only once
flips <- 0
nheads <- 0 #these are both outputs
while (nheads < 3) { #sequence: continue looping while the number of flips results in "heads"
if (flip() == "H") { #another conditional: if the result of `flip()` is "H", then do something
nheads <- nheads + 1 #add 1 to the nheads vector
} else { #else do this
nheads <- 0 #reset to 0
}
flips <- flips + 1 #add 1 to flips as we iterate through the prior conditional
} #the while loop will stop once the first conditional is met
flips #print the number of flips needed
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
df %>%
map_dbl(mean)
df %>%
map_dbl(df, mean, trim = 0.5)
df %>%
map_dbl(mean, trim = 0.5)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
str(models)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
summary(models)
summary(models[[1]])
summary(models[[1]]) #to access each element, use [[]]
summary(models[[2]])
summary(models[[3]])
models <-
map(summary)
models %>%
map(summary)
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map_dbl("Coefficients")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("Coefficients")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("residuals")
mu <- list(5,10,25,50,100)
mu.df <- mu %>%
map(rnorm, n = 10)
str(mu.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
head(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
#arguments can be named as well to help clarify code
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
#arguments can be named as well to help clarify code
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
head(args1)
head(args2)
params <- tribble(mu, sigma, m)
params <- tribble(
mu = mu,
sigma = sigma,
m = m
)
m
params <- tribble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
m
params <- tribble(
mu = unlist(mu),
sigma = unlist(sigma)#,
#m = unlist(m)
)
mu
unlist(mu)
unlist(sigma)
unlist(m)
params <- tibble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
params
params <- tibble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
params
params %>%
pmap(rnorm)
params <- tibble(
mean = unlist(mu),
sd = unlist(sigma),
n = unlist(m)
)
params
params %>%
pmap(rnorm)
x <- list(1, "a", 3)
x %>%
walk(print)
dir.crate("images")
dir.create("images")
dir.create("images")
plots <- mtcars %>%
split(.$cyl) %>%
map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf") #generate strings of names
pwalk(list(paths, plots), ggsave, path = "images/")
library(tidyverse)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
str(df)
mean(df$a)
mean(df$b)
mean(df$c)
mean(df$d)
View(df)
results <- vector("double", ncol(df))
for (i in seq_along(df)) {
results[[i]] <- mean(df[[i]])
}
results
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output)
output <- unlist(list.output) #combine together
print(output)
#A simple while loop that shows us how many tries it takes to get three heads in a row
flip <- function() sample(c("T", "H"), 1) #sample from "T"|"H" only once
flips <- 0
nheads <- 0 #these are both outputs
while (nheads < 3) { #sequence: continue looping while the number of flips results in "heads"
if (flip() == "H") { #another conditional: if the result of `flip()` is "H", then do something
nheads <- nheads + 1 #add 1 to the nheads vector
} else { #else do this
nheads <- 0 #reset to 0
}
flips <- flips + 1 #add 1 to flips as we iterate through the prior conditional
} #the while loop will stop once the first conditional is met
flips #print the number of flips needed; your number will be different
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
df %>%
map_dbl(mean)
df %>%
map_dbl(mean, trim = 0.5)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
summary(models)
summary(models[[1]]) #to access each element, use [[]]
summary(models[[2]])
summary(models[[3]])
models %>%
map(summary)
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("residuals")
mu <- list(5,10,25,50,100)
mu.df <- mu %>%
map(rnorm, n = 10)
str(mu.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
head(args1)
head(args2)
params <- tibble(
mean = unlist(mu),
sd = unlist(sigma),
n = unlist(m)
)
params
params %>%
pmap(rnorm)
View(params)
View(params)
x <- list(1, "a", 3)
x %>%
walk(print)
dir.create("images")
plots <- mtcars %>%
split(.$cyl) %>%
map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf") #generate strings of names
pwalk(list(paths, plots), ggsave, path = "images/")
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
data <- cars
cars
library(tidyverse)
data <- diamonds
diamonds
diamonds %>%
group_by(cut, color) %>%
summarize(mPrice = mean(price))
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price))
suppressMessages(library(tidyverse))
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price))
suppressMessages(library(tidyverse))
data <- diamonds
diamonds
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(aes(stat = "identity"))
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(stat = "identity")
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(stat = "identity") +
labs(main = "Pretty graph")
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(stat = "identity") +
labs(title = "Pretty graph")
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(stat = "identity") +
labs(title = "Not so Pretty graph")
library(tidyverse)
H1 <- readxl::read_xlsx("~/Dropbox/UFLab/Papiamentu/Coded data/H1.xlsx")
head(H1)
for(i in 1:41){
assign(paste0("H",i), readxl::read_xlsx(paste0("~/Dropbox/UFLab/Papiamentu/Coded data/H",i,".xlsx")))
Participant <- paste0("H",i)
assign(paste0("H",i), as_tibble(cbind(eval(parse(text = paste0("H",i))), Participant)))
}
total <- H1
#there is a problem with H12 where the "Response" column needs to be written as "Response_button"
names(H12)[4] <- "Response_button"
for(i in 1:41){
total <- rbind(total, eval(parse(text = paste0("H", i))))
}
head(total)
levels(total$Participant)
write_csv(total, "Papiamentu_group.csv", row.names = FALSE)
write_csv(total, "Papiamentu_group.csv")
setwd("~/Documents/Methods/Tutorials")
library(tidyverse)
sample <- read.csv("data/sample_data.csv")
sample
sample2 <- read_csv("data/sample_data.csv")
sample2 <- read_csv("data/sample_data.csv")
sample2
mean(sample3$count[sample$aux_type == "E"])
mean(sample3$count[sample3$aux_type == "E"])
mean(sample2$count[sample2$aux_type == "E"])
mean(sample2$count[sample2$aux_type == "H"])
sample2
mean(sample2$count[sample2$aux_type == "E"])
mean(sample2$count[sample2$aux_type == "H"])
sample2
mean(sample2$count[sample2$aux_type == "E" & sample2$response_accuracy == "correct"])
mean(sample2$count[sample2$aux_type == "H"& sample2$response_accuracy == "correct"])
plot(cars)
