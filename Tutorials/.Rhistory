sum(is.na(group3$Target.RT))
group4 <- group3[complete.cases(group3$Target.RT),]
group5 <- subset(group4, Target.RT >= 300)
group.rel <- subset(group5, Accuracy == 1)
group.rel <- ddply(group5, .(Subject),mutate, rel_max = mean(Target.RT) + 2.5*sd(Target.RT), rel_min = mean(Target.RT) - 2.5*sd(Target.RT))
group.rel$min_out <- ifelse(group.rel$Target.RT <= group.rel$rel_min,1,0)
group.rel$max_out <- ifelse(group.rel$Target.RT >= group.rel$rel_max,1,0)
group.rel$RT_final <- ifelse(group.rel$Target.RT >= group.rel$rel_max, group.rel$rel_max, ifelse(group.rel$Target.RT <= group.rel$rel_min, group.rel$rel_min, group.rel$Target.RT))
write.csv(group.rel, "Group_DataTrimmed_041117.csv", row.names = FALSE)
subj.means <- ddply(group.rel, .(Subject, Group, Session.order, Congruency, ResponseType), summarize, RT.MEAN = mean(Target.RT), RT.SE = sd(Target.RT)/length(Target.RT))
write.csv(subj.means, "Subj_Means_041117.csv", row.names = FALSE)
str(subj.means)
ggplot(subj.means, aes(ResponseType, RT.MEAN, fill = Congruency)) + stat_summary(fun.y = mean, geom = "bar", position = "dodge") + stat_summary(fun.data = mean_se, geom = "errorbar", position = "dodge") + facet_grid(Group~Session.order)
ggsave("Groups_RT_041117.png", height = 5, width = 7)
group.ez <- ezANOVA(data = subj.means,
dv = RT.MEAN,
wid = Subject,
within = .(Congruency, ResponseType, Session.order),
between = Group
)
bi.ez <- ezANOVA(data = subj.means[subj.means$Group == "Bilingual",],
dv = RT.MEAN,
wid = Subject,
within = .(Congruency, ResponseType, Session.order)#,
#between = Group
)
group.ez
head(subj.means)
group.ez <- ezANOVA(data = subj.means,
dv = RT.MEAN,
wid = Subject,
within = .(Congruency, ResponseType, Session.order),
between = Group
)
subj.means
head(subj.means)
str(subj.means)
subj.means <- subset(subj.means, Subject != "48" & Group == "Bilingual" | Subject ! = "49" & Group == "Bilingual")
subj.means <- subset(subj.means, Subject != "48" | Subject ! = "49")
?subset
subj.means <- subset(subj.means, Subject != "48")
subj.means <- subset(subj.means, Subject != "49")
subj.means$Subject <- factor(subject.means$Subject)
subj.means$Subject <- factor(subj.means$Subject)
group.ez <- ezANOVA(data = subj.means,
dv = RT.MEAN,
wid = Subject,
within = .(Congruency, ResponseType, Session.order),
between = Group
)
sum(24936,25684,26454)
sum(9815,7690,7431)
load(mtcars)
head(mtcars)
sum(.66,1.5,.25,1,.75)
100-4.16
59.58/59.35
59.58/59.35/100
59.58/59.35/100-1
59.35/59.58
1-59.35/59.58
(1-59.35/59.58)*100
(1-242.55/27.50)*100
(1-242.55/247.50)*100
(1-181.54/184.66)*100
(1-61.46/62.24)*100
(1-60.48/61.15)*100
10662.68-5268.25
10662.68-5394.43
5268.25-1807.59
citation()
?grep
version()
Version()
install.packages(c("tidyverse","car","ez","effects","lmer"))
install.packages("lme4")
sum(395, 100, 460, 144)
sum(395,100,460)
12000-10767
a <- 3
b <- 4
c <- a*b
c
library(tidyverse)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
print(tibble)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
print(df)
mean(df$a)
mean(df$b)
mean(df$c)
mean(df$d)
results <- vector("double", ncol(df)) #create a vector that is of class "double", that is the length of the number of columns in **df**
for (i in seq_along(df)) {
results[[i]] <- mean(df[[i]])
}
results
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
str(output)
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
head(output)
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
print(output)
#A simple while loop that shows us how many tries it takes to get three heads in a row
flip <- function() sample(c("T", "H"), 1) #sample from "T"|"H" only once
flips <- 0
nheads <- 0 #these are both outputs
while (nheads < 3) { #sequence: continue looping while the number of flips results in "heads"
if (flip() == "H") { #another conditional: if the result of `flip()` is "H", then do something
nheads <- nheads + 1 #add 1 to the nheads vector
} else { #else do this
nheads <- 0 #reset to 0
}
flips <- flips + 1 #add 1 to flips as we iterate through the prior conditional
} #the while loop will stop once the first conditional is met
flips #print the number of flips needed
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
df %>%
map_dbl(mean)
df %>%
map_dbl(df, mean, trim = 0.5)
df %>%
map_dbl(mean, trim = 0.5)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
str(models)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
summary(models)
summary(models[[1]])
summary(models[[1]]) #to access each element, use [[]]
summary(models[[2]])
summary(models[[3]])
models <-
map(summary)
models %>%
map(summary)
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map_dbl("Coefficients")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("Coefficients")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("residuals")
mu <- list(5,10,25,50,100)
mu.df <- mu %>%
map(rnorm, n = 10)
str(mu.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
head(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
#arguments can be named as well to help clarify code
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
#arguments can be named as well to help clarify code
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
head(args1)
head(args2)
params <- tribble(mu, sigma, m)
params <- tribble(
mu = mu,
sigma = sigma,
m = m
)
m
params <- tribble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
m
params <- tribble(
mu = unlist(mu),
sigma = unlist(sigma)#,
#m = unlist(m)
)
mu
unlist(mu)
unlist(sigma)
unlist(m)
params <- tibble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
params
params <- tibble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
params
params %>%
pmap(rnorm)
params <- tibble(
mean = unlist(mu),
sd = unlist(sigma),
n = unlist(m)
)
params
params %>%
pmap(rnorm)
x <- list(1, "a", 3)
x %>%
walk(print)
dir.crate("images")
dir.create("images")
dir.create("images")
plots <- mtcars %>%
split(.$cyl) %>%
map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf") #generate strings of names
pwalk(list(paths, plots), ggsave, path = "images/")
library(tidyverse)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
str(df)
mean(df$a)
mean(df$b)
mean(df$c)
mean(df$d)
View(df)
results <- vector("double", ncol(df))
for (i in seq_along(df)) {
results[[i]] <- mean(df[[i]])
}
results
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output)
output <- unlist(list.output) #combine together
print(output)
#A simple while loop that shows us how many tries it takes to get three heads in a row
flip <- function() sample(c("T", "H"), 1) #sample from "T"|"H" only once
flips <- 0
nheads <- 0 #these are both outputs
while (nheads < 3) { #sequence: continue looping while the number of flips results in "heads"
if (flip() == "H") { #another conditional: if the result of `flip()` is "H", then do something
nheads <- nheads + 1 #add 1 to the nheads vector
} else { #else do this
nheads <- 0 #reset to 0
}
flips <- flips + 1 #add 1 to flips as we iterate through the prior conditional
} #the while loop will stop once the first conditional is met
flips #print the number of flips needed; your number will be different
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
df %>%
map_dbl(mean)
df %>%
map_dbl(mean, trim = 0.5)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
summary(models)
summary(models[[1]]) #to access each element, use [[]]
summary(models[[2]])
summary(models[[3]])
models %>%
map(summary)
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("residuals")
mu <- list(5,10,25,50,100)
mu.df <- mu %>%
map(rnorm, n = 10)
str(mu.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
head(args1)
head(args2)
params <- tibble(
mean = unlist(mu),
sd = unlist(sigma),
n = unlist(m)
)
params
params %>%
pmap(rnorm)
View(params)
View(params)
x <- list(1, "a", 3)
x %>%
walk(print)
dir.create("images")
plots <- mtcars %>%
split(.$cyl) %>%
map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf") #generate strings of names
pwalk(list(paths, plots), ggsave, path = "images/")
knitr::opts_chunk$set(echo = TRUE)
2+6
12-5
3*8
44/7
2^3
print("<")
sqrt(4)
sum(2,6,8)
rnorm(10)
rnorm(10, mean = 1000, sd = 300)
a <- 3
b <- 6
a*b
c <- a*b
c
seq1 <- rnorm(10)
seq2 <- rnorm(10, mean = 20, sd = 2)
seq1 <- rnorm(10)
seq2 <- rnorm(10, mean = 20, sd = 2)
seq3 <- rnorm(7, mean = 30, sd = 4)
seq2 - seq1
seq2/4
seq3 - se2
seq2 - seq1
seq2/4
seq3 - seq2
values <- c(2,7,8,3,2,9,7)
values <- c(2,7,8,3,2,9,7)
#try doing so without the c() command
values2 <- c(2,7,8,3,2,9,7)
values <- c(2,7,8,3,2,9,7)
#try doing so without the c() command
values2 <- (2,7,8,3,2,9,7)
weight <- c(60, 72, 57, 90, 95, 72)
height <- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91)
bmi <- weight/height^2
bmi
values <- c(2,7,8,3,2,9,7)
#try doing so without the c() command
#values2 <- (2,7,8,3,2,9,7)
sample <- read.csv("data/sample_data.csv")
head(sample) #prints first 6 rows
tail(sample) #prints last 6 rows
str(sample) #gives structure of data columns
summary(sample) #gives summary for each column
sample[6,]
sample[,3]
sample[6,3]
sample$response_accuracy
sample[sample$response_accuracy == "correct",]
mean(sample$prop[sample$response_accuracy == "correct"])
?subset()
2+6
3*4
?rnorm()
rep(1:4, 2)
a <- 3
b <- 6
a*b
c <- a*b
c
seq1 <- rnorm(10)
seq2 <- rnorm(10, mean = 20, sd = 2)
seq3 <- rnorm(7, mean = 30, sd = 4)
d <- seq3[3]
seq2-seq1
seq3/2
seq3-seq2
values <- c(2,3,4,5,9)
values <- 2,3,4,5,9
values2 <- 2,3,4,5,9
weight <- c(60, 72, 57, 90, 95, 72)
height <- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91)
bmi <- weight/height^2
bmi
plot(weight,height)
setwd("~/Documents/Methods/Tutorials")
sample <- read.csv("data/sample_data.csv")
View(sample)
head(sample)
tail(sample)
str(sample)
sample[6,]
sample[,3]
sample[6,3]
sample$response_accuracy
sample[sample$response_accuracy == "correct",]
head(airquality)
subset(airquality, Temp > 80, select = c(Ozone, Temp))
subset(airquality, Temp > 80)
subset(sample, response_accuracy == "correct" & prop > 80)
subset(sample, response_accuracy == "correct", prop > 80)
subset(sample, response_accuracy = "correct" & prop > 80)
subset(sample, response_accuracy == "correct", prop > 80)
subset(sample, response_accuracy = "correct" & prop > 80)
