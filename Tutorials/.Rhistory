Version()
install.packages(c("tidyverse","car","ez","effects","lmer"))
install.packages("lme4")
sum(395, 100, 460, 144)
sum(395,100,460)
12000-10767
a <- 3
b <- 4
c <- a*b
c
library(tidyverse)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
print(tibble)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
print(df)
mean(df$a)
mean(df$b)
mean(df$c)
mean(df$d)
results <- vector("double", ncol(df)) #create a vector that is of class "double", that is the length of the number of columns in **df**
for (i in seq_along(df)) {
results[[i]] <- mean(df[[i]])
}
results
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
str(output)
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
head(output)
#If you don't know the ouptput length (if you are randomly generating or sampling something), then you could save the results of each "run" to a list, then combine after the loop is done:
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output) #check out structure of output
output <- unlist(list.output) #combine together
print(output)
#A simple while loop that shows us how many tries it takes to get three heads in a row
flip <- function() sample(c("T", "H"), 1) #sample from "T"|"H" only once
flips <- 0
nheads <- 0 #these are both outputs
while (nheads < 3) { #sequence: continue looping while the number of flips results in "heads"
if (flip() == "H") { #another conditional: if the result of `flip()` is "H", then do something
nheads <- nheads + 1 #add 1 to the nheads vector
} else { #else do this
nheads <- 0 #reset to 0
}
flips <- flips + 1 #add 1 to flips as we iterate through the prior conditional
} #the while loop will stop once the first conditional is met
flips #print the number of flips needed
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
df %>%
map_dbl(mean)
df %>%
map_dbl(df, mean, trim = 0.5)
df %>%
map_dbl(mean, trim = 0.5)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
str(models)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
summary(models)
summary(models[[1]])
summary(models[[1]]) #to access each element, use [[]]
summary(models[[2]])
summary(models[[3]])
models <-
map(summary)
models %>%
map(summary)
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map_dbl("Coefficients")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("Coefficients")
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("residuals")
mu <- list(5,10,25,50,100)
mu.df <- mu %>%
map(rnorm, n = 10)
str(mu.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
head(mu.sd.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
#arguments can be named as well to help clarify code
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
#arguments can be named as well to help clarify code
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
head(args1)
head(args2)
params <- tribble(mu, sigma, m)
params <- tribble(
mu = mu,
sigma = sigma,
m = m
)
m
params <- tribble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
m
params <- tribble(
mu = unlist(mu),
sigma = unlist(sigma)#,
#m = unlist(m)
)
mu
unlist(mu)
unlist(sigma)
unlist(m)
params <- tibble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
params
params <- tibble(
mu = unlist(mu),
sigma = unlist(sigma),
m = unlist(m)
)
params
params %>%
pmap(rnorm)
params <- tibble(
mean = unlist(mu),
sd = unlist(sigma),
n = unlist(m)
)
params
params %>%
pmap(rnorm)
x <- list(1, "a", 3)
x %>%
walk(print)
dir.crate("images")
dir.create("images")
dir.create("images")
plots <- mtcars %>%
split(.$cyl) %>%
map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf") #generate strings of names
pwalk(list(paths, plots), ggsave, path = "images/")
library(tidyverse)
df <- tibble(
a = rnorm(10),
b = rnorm(10),
c = rnorm(10),
d = rnorm(10)
)
str(df)
mean(df$a)
mean(df$b)
mean(df$c)
mean(df$d)
View(df)
results <- vector("double", ncol(df))
for (i in seq_along(df)) {
results[[i]] <- mean(df[[i]])
}
results
means <- c(0, 5, 10) #create a vector of means
list.output <- vector("list", length(means)) #output
for (i in seq_along(means)) { #sequence
n <- sample(100, 1) #from 0:100, choose one random number
list.output[[i]] <- rnorm(n, means[[i]]) #generate a random normal distribution of n numbers, with mean from sequence
}
str(list.output)
output <- unlist(list.output) #combine together
print(output)
#A simple while loop that shows us how many tries it takes to get three heads in a row
flip <- function() sample(c("T", "H"), 1) #sample from "T"|"H" only once
flips <- 0
nheads <- 0 #these are both outputs
while (nheads < 3) { #sequence: continue looping while the number of flips results in "heads"
if (flip() == "H") { #another conditional: if the result of `flip()` is "H", then do something
nheads <- nheads + 1 #add 1 to the nheads vector
} else { #else do this
nheads <- 0 #reset to 0
}
flips <- flips + 1 #add 1 to flips as we iterate through the prior conditional
} #the while loop will stop once the first conditional is met
flips #print the number of flips needed; your number will be different
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
df %>%
map_dbl(mean)
df %>%
map_dbl(mean, trim = 0.5)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
head(mtcars)
str(mtcars)
summary(mtcars)
unique(mtcars$cyl)
models <- mtcars %>%
split(.$cyl) %>%
map(~lm(mpg ~ wt, data = .))
summary(models)
summary(models[[1]]) #to access each element, use [[]]
summary(models[[2]])
summary(models[[3]])
models %>%
map(summary)
models %>%
map(summary) %>%
map_dbl("r.squared")
models %>%
map(summary) %>%
map("residuals")
mu <- list(5,10,25,50,100)
mu.df <- mu %>%
map(rnorm, n = 10)
str(mu.df)
sigma <- list(1, 3, 5, 2, .5)
mu.sd.df <- map2(mu, sigma, rnorm, n = 10)
str(mu.sd.df)
m <- list(1,3,5,7,9)
args1 <- list(m, mu, sigma)
args1 %>%
pmap(rnorm) %>%
str()
args2 <- list(mean = mu, sd = sigma, n = m)
args2 %>%
pmap(rnorm) %>%
str()
head(args1)
head(args2)
params <- tibble(
mean = unlist(mu),
sd = unlist(sigma),
n = unlist(m)
)
params
params %>%
pmap(rnorm)
View(params)
View(params)
x <- list(1, "a", 3)
x %>%
walk(print)
dir.create("images")
plots <- mtcars %>%
split(.$cyl) %>%
map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf") #generate strings of names
pwalk(list(paths, plots), ggsave, path = "images/")
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
data <- cars
cars
library(tidyverse)
data <- diamonds
diamonds
diamonds %>%
group_by(cut, color) %>%
summarize(mPrice = mean(price))
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price))
suppressMessages(library(tidyverse))
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price))
suppressMessages(library(tidyverse))
data <- diamonds
diamonds
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(aes(stat = "identity"))
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(stat = "identity")
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(stat = "identity") +
labs(main = "Pretty graph")
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(stat = "identity") +
labs(title = "Pretty graph")
diamonds %>%
group_by(cut) %>%
summarize(mPrice = mean(price)) %>%
ggplot(data = ., aes(x = cut, y = mPrice)) +
geom_bar(stat = "identity") +
labs(title = "Not so Pretty graph")
setwd("~/Documents/Methods/Tutorials")
library(tidyverse)
cs <- read_csv("data/CSLex_Subset.csv")
cs <- read_csv("data/CSLex_Subset.csv")
cs
cs <- read_csv("data/CSLex_Subset.csv")
str(cs)
cs <- read_csv("data/CSLex_Subset.csv")
glimpse(cs)
ggplot(cs, aes(x = Type)) + geom_bar
ggplot(cs, aes(x = Type)) + geom_bar()
ggplot(cs, aes(x = Birth)) + geom_bar()
cs %>%
count(Birth)
ggplot(cs, aes(x = Subject)) + geom_bar()
ggplot(cs, aes(x = Time.100)) + geom_histogram()
ggplot(cs, aes(x = Target)) + geom_histogram()
summary(cs$Target)
cs[cs$Target == "2967",]
ggplot(cs, aes(x = Target)) + geom_histogram()
ggplot(cs, aes(x = Distractor)) + geom_histogram()
ggplot(cs, aes(x = Target)) + geom_histogram(binwidth = 100)
ggplot(cs, aes(x = Target)) + geom_histogram(binwidth = 100)
ggplot(cs, aes(x = Target)) + geom_histogram(binwidth = 200)
ggplot(cs, aes(x = Target)) + geom_histogram(binwidth = 50)
ggplot(cs, aes(x = Target)) + geom_histogram()
ggplot(cs, aes(x = Target)) + geom_histogram(binwidth = 100)
ggplot(cs, aes(x = Target)) + geom_histogram(binwidth = 200)
ggplot(cs, aes(x = Target)) + geom_histogram(binwidth = 50)
ggplot(cs, aes(x = Target)) +
geom_histogram() +
facet_wrap(~Subject)
ggplot(cs, aes(x = Target)) +
geom_histogram(binwidth = 200) +
facet_wrap(~Subject)
ggplot(cs, aes(x = Track_Loss)) +
geom_histogram() +
facet_wrap(~Subject)
ggplot(cs, aes(x = Track_Loss)) +
geom_histogram(binwidth = 50) +
facet_wrap(~Subject)
cs %>%
mutate(cTrack_Loss = ifelse(Track_Loss > 200, NA, Track_Loss))
cs2 <- cs %>%
mutate(cTrack_Loss = ifelse(Track_Loss > 200, NA, Track_Loss))
mean(cs$Track_Loss)
mean(cs2$cTrack_Loss)
mean(cs2$cTrack_Loss, na.rm = TRUE)
cs2 %>%
mutate(missing_Track_Loss = is.na(cTrack_Loss)) %>%
ggplot(data = ., aes(cTrack_Loss)) +
geom_freqpoly(aes(color = missing_Track_Loss))
cs3 <- cs2 %>%
mutate(missing_Track_Loss = is.na(cTrack_Loss))
ggplot(data = cs3, aes(cTrack_Loss)) +
geom_freqpoly(aes(color = missing_Track_Loss))
cs3 <- cs2 %>%
mutate(missing_Track_Loss = is.na(cTrack_Loss))
ggplot(data = cs3, aes(cTrack_Loss)) +
geom_freqpoly(aes(color = missing_Track_Loss, binwidth =5))
cs3 <- cs2 %>%
mutate(missing_Track_Loss = is.na(cTrack_Loss))
ggplot(data = cs3, aes(cTrack_Loss)) +
geom_freqpoly(aes(color = missing_Track_Loss), binwidth = 5)
cs3 <- cs2 %>%
mutate(missing_Track_Loss = is.na(cTrack_Loss))
ggplot(data = cs3, aes(Time.100)) +
geom_freqpoly(aes(color = missing_Track_Loss), binwidth = 5)
cs3 <- cs2 %>%
mutate(missing_Track_Loss = is.na(cTrack_Loss))
ggplot(data = cs3, aes(Time.100)) +
geom_freqpoly(aes(color = missing_Track_Loss), binwidth = 100)
cs3 <- cs2 %>%
mutate(missing_Track_Loss = is.na(cTrack_Loss))
ggplot(data = cs3, aes(Time.100)) +
geom_freqpoly(aes(color = missing_Track_Loss), binwidth = 50)
cs3 <- cs2 %>%
mutate(missing_Track_Loss = is.na(cTrack_Loss))
ggplot(data = cs3, aes(Time.100)) +
geom_freqpoly(aes(color = missing_Track_Loss), binwidth = 100)
ggplot(cs, aes(x = Target)) +
geom_freqpoly(aes(color = Gender))
ggplot(cs, aes(x = Target)) +
geom_freqpoly(aes(color = Type))
cs %>%
count(Gender, Type)
View(cs3)
cs3 %>%
count(Participant, missing_Track_Loss)
cs3 %>%
count(Subject, missing_Track_Loss)
cs3 %>%
count(Subject, missing_Track_Loss) %>%
arrange(Subject)
cs3 %>%
count(Subject, missing_Track_Loss) %>%
arrange(Subject, missing_Track_Loss)
cs3 %>%
arrange(Subject) %>%
count(Subject, missing_Track_Loss)
cs3 %>%
count(missing_Track_Loss, Subject)
cs3 %>%
count(missing_Track_Loss, Subject) %>%
arrange(Subject)
ggplot(cs, aes(x = Time.100, Target)) +
geom_point(alpha = 1/100)
ggplot(cs, aes(x = Target, Distractor)) +
geom_point(alpha = 1/100)
ggplot(cs, aes(x = Target, Distractor)) +
geom_point(position = jitter)
ggplot(cs, aes(x = Target, Distractor)) +
geom_point(position = "jitter"")
ggplot(cs, aes(x = Target, Distractor)) +
geom_point(position = "jitter")
ggplot(cs, aes(x = Track_Loss)) +
geom_histogram(binwidth = 600) +
facet_wrap(~Subject)
ggplot(cs, aes(x = Track_Loss)) +
geom_histogram(binwidth = 50) +
facet_wrap(~Subject)
